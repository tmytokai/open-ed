// ADC 初期化
void init_adc(void)
{
    // ポート A,B の入出力設定です
    // 0 にすると入力モード、1 にすると出力モードになります
    // 詳しくはデータシート 120p(ポートA)と126p(ポートB) を参照してください
    TRISA =  TRISA  | 0b? ;
    TRISB =  TRISB  | 0b? ;

    // ポート A,b のアナログ設定です
    // 0 にするとデジタル入出力モード、1 にするとアナログ入力モードになります
    // 詳しくはデータシート 122p(ポートA)と128p(ポートB) を参照してください
    ANSELA = ANSELA | 0b? ;
    ANSELB = ANSELB | 0b? ;

    // 1 を入れるとAD変換機能をONにします
    // 詳しくはデータシート 143p を参照してください
    ADCON0bits.ADON = ? ;

    // 結果の出力形式を右詰めにするか左詰めにするかの設定です
    // 1が右詰め、0が左詰めです
    // 今回は右詰めにします
    // 詳しくはデータシート 140p の図15-3と 144p を参照してください
    ADCON1bits.ADFM = ? ;

    // 入力するチャンネル(ポート)の設定です
    // ANx の x を指定します (xの範囲は0〜11)
    // 1827はAD変換モジュールを1つしか持ってないので同時に1チャンネルしかAD変換できません
    // そのため複数チャンネルでAD変換を行いたい場合はチャンネルを切り替えながら使います
    // 詳しくはデータシート 143p を参照してください
    ADCON0bits.CHS = ? ;

    // チャンネルをセットしたらアクイジョンタイムを入れて準備完了まで少し待ちます
    // 今回は適当に 20 マイクロ秒としますが、時間を真面目に計算したい場合は 147p の計算式を参照してください
    __delay_us(20);
}

// ADC 変換
int adc_convert(void){

    // AD変換を開始します
    // 1 を入れると変換を始めて、変換が終わると 0 に戻ります
    // 詳しくはデータシート 143p を参照してください
    ADCON0bits.GO_nDONE = ? ;
    while( ADCON0bits.GO_nDONE ) continue;

    // AD変換の結果は 10bit の値として ADRESH と ADRESL に入ります
    // 10bitなので 0〜3.3V の入力が 0〜1023 の整数値に変換されます
    // なお今回は ADCON1bit.ADFM = 1 としてるので出力形式は右詰めになります
    // 詳しくはデータシート 140p の図15-3 を参照してください
    return ADRESH * ? + ADRESL;
}

void main(void){

    init();
    init_input();
    init_uart();
    init_adc();
  
    while(1){
      int adc = adc_convert();
      printf("ADC = %d\r\n",adc);
      __delay_ms(1000);
    }
    
    return;
}
