#include "setting.h"

// ADC 初期化
void init_adc(void)
{
    // ポート A,B の入出力設定を上書きします
    // 0 にすると出力モード、1 にすると入力モードになります
    // 詳しくはデータシート 120p(ポートA)と126p(ポートB) を参照してください
    TRISA =  TRISA  | ? ;
    TRISB =  TRISB  | 0b00000000; 

    // ポート A,B のアナログ入力を上書きします
    // 0 にするとデジタル入出力モード、1 にするとアナログ入力モードになります
    // アナログ入力モードにする場合は対応する TRISx も入力モードにして下さい
    // 詳しくはデータシート 122p(ポートA)と128p(ポートB) を参照してください
    ANSELA = ANSELA | ? ;
    ANSELB = ANSELB | 0b00000000;

    // ADCのクロック設定です
    // 早すぎると正しく変換できないので、139p表 15-1 で影が入ってないマス目のスピードを選びます
    // 詳しくはデータシート 139p表 15-1 と 144p を参照して下さい
    ADCON1bits.ADCS = 0b100;  // FOSC=4MHzの時は FOSC/4 が最適

    // 1 をセットするとADCモジュールがONになります
    // 詳しくはデータシート 143p を参照してください
    ADCON0bits.ADON = ? ;

    // 結果の出力形式を右詰めにするか左詰めにするかの設定です
    // 1が右詰め、0が左詰めです
    // 今回は右詰めにします
    // 詳しくはデータシート 140p の図 15-3と 144p を参照してください
    ADCON1bits.ADFM = ? ;
}

// ADC 変換
int adc(int chn){
    
    // 入力するチャンネル(ポート)の設定です
    // ANx の x を指定します (xの範囲は0〜11)
    // 1827はAD変換モジュールを1つしか持ってないので同時に1チャンネルしかAD変換できません
    // そのため複数チャンネルでAD変換を行いたい場合はチャンネルを切り替えながら使います
    // 詳しくはデータシート 143p を参照してください
    ADCON0bits.CHS = ? ;

    // チャンネルをセットしたらアクイジョンタイムを入れて準備完了まで少し待ちます
    // 今回は適当に 20 マイクロ秒としますが、時間を真面目に計算したい場合は 147p の計算式を参照してください
    __delay_us(20);
    
    // AD変換を開始します
    // 1 を入れると変換を始めて、変換が終わると 0 に戻ります
    // 詳しくはデータシート 143p を参照してください
    ADCON0bits.GO_nDONE = ? ;
    while( ADCON0bits.GO_nDONE ) continue;

    // AD変換の結果は 10bit の値として ADRESH と ADRESL に入ります
    // 10bitなので 0 V 〜 動作電圧 V の入力が 0〜1023 の整数値に変換されます
    // なお今回は ADCON1bit.ADFM = 1 としてるので出力形式は右詰めになります
    // 詳しくはデータシート 140p の図 15-3 を参照してください
    return ADRESH * ? + ADRESL;
}
