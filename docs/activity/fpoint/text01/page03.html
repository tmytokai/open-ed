<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="stylesheet" href="../../../common.css">
<script src="../../../common.js"></script>
<script src="../../../mathjax.js"></script>
<title>3. 0以上かつ1より小さい小数</title>
</head>
<body>

<nav class="brcr">
<ol>
<li><a href="../">アクティビティ: 浮動小数点数</a></li>
<li>学習項目: [1] 10進数から2進数への基数変換</li>
<li><script>GetTitle()</script></li>
</ol>
</nav>

<h2><script>GetTitle()</script></h2>

<p>
次は0以上かつ1より小さい小数を 2 進数に基数変換する方法について説明します。
<br>
なお負の範囲(0より小さいかつ-1より大きい)にある小数は前ページと同様に<a href="./page02.html">2 の補数演算</a>によって計算できます。
</p>

<p>
さて<a href="./page01.html">整数の場合</a>は元の値を 2 で割っていましたが、小数の場合は以下の様に 2 をかけて演算していきます。
</p>

<div class="info">
<input type="checkbox"> <b> 0 以上かつ 1 より小さい小数を 2 進数に変換</b>

<p>
A を $ 0 \le \textrm{A} < 1$ の 10 進数の小数とする
</p>

<ol>
<li> 有効桁数(精度とも言います) n ビットを決める ※ 1 以上にする
<li> A に 2 をかける。この時の積の整数部分を $r_{-1}$、積から $r_{-1}$ を引いた残りを $p_{-1}$ とする
<li> $p_{-1}$ に 2 をかける。この時の積の整数部分を $r_{-2}$、積から $r_{-2}$ を引いた残りを $p_{-2}$ とする
<li> $p_{-2}$ に 2 をかける。この時の積の整数部分を $r_{-3}$、積から $r_{-3}$ を引いた残りを $p_{-3}$ とする
<li> これを n+1 回繰り返す
<li> $r_{-1}$ を先頭に $r_{-(n+1)}$ まで順に並べる
<li> 0b を先頭に付ける ※ 2 進数を意味する接頭語
<li> この時点で n+1 ビットの 2 進数 0b $r_{-1}r_{-2}\cdots r_{-(n-1)}r_{-n}r_{-(n+1)}$ が得られる
<li> 最後のビット($r_{-(n+1)}$) が 0 だったら n+1 ビット目を切り捨てて先頭から n ビットの 2進数にする
<li> 最後のビット($r_{-(n+1)}$) が 1 だったら n+1 ビット目を切り上げて先頭から n ビットの 2進数にする
<li> n ビットの 2 進数 0b $r_{-1}r_{-2}\cdots r_{-(n-1)}r_{-n}$ が得られる
</ol>

<p>
※ (9)(10)の処理のことを「<b>最近接偶数丸め</b>」と呼びます
</p>

</div>

<p>
次は逆に 2 進数を 0 以上かつ 1 より小さい小数に基数変換します。
</p>

<div class="info">
<input type="checkbox"> <b>2 進数を 0 以上かつ 1 より小さい小数に変換</b>

<p>
n ビットの 2 進数が 0b $r_{-1}r_{-2}\cdots r_{-(n-1)}r_{-n}$ で与えられる時、
</p>

<p>
A = $r_{-1}\cdot2^{-1} + r_{-2}\cdot2^{-2} + \cdots + r_{-(n-1)}\cdot 2^{-(n-1)} + r_{-n}\cdot 2^{-n} $
</p>

<p>
と 10 進数が得られる
</p>

</div>


<p>
では例として A = 0.625 を有効桁数 n = 4 で 2 進数に変換してみましょう。
</p>

<div class="info">
<input type="checkbox"> <b>例: 0.625 を 2 進数に変換 (n = 4 )</b>

<p>
A = 0.625 とする
</p>

<ol>
<li> 有効桁数 を n = 4 ビットとする
<li> A に 2 をかけると 1.25 。積の整数部分は $r_{-1} = 1$、積から $r_{-1}$ を引いた残りは $p_{-1} = 0.25$
<li> $p_{-1} = 0.25 $ に 2 をかけると 0.5 。積の整数部分は $r_{-2} = 0$、積から $r_{-2}$ を引いた残りは $p_{-2} = 0.5$
<li> $p_{-2} = 0.5 $ に 2 をかけると 1 。積の整数部分は $r_{-3} = 1$、積から $r_{-3}$ を引いた残りは $p_{-3} = 0$
<li> $p_{-3} = 0 $ に 2 をかけると 0 。積の整数部分は $r_{-4} = 0$、積から $r_{-4}$ を引いた残りは $p_{-4} = 0$
<li> $p_{-4} = 0 $ に 2 をかけると 0 。積の整数部分は $r_{-5} = 0$、積から $r_{-5}$ を引いた残りは $p_{-5} = 0$
<li> n = 4+1 = 5 回繰り返したので計算終了
<li> $r_{-1}$ を先頭に $r_{-5}$ まで順に並べると 10100
<li> 0b を先頭に付けると 0b10100
<li> 最後のビット($r_{-5})$ が 0 なので最後のビットを切り捨てる
<li> n = 4 ビットの2進数 0b1010 が得られる
</ol>

</div>

<p>
ちなみに A は 0.625 = 5/8 と、分母が 2、4、8、・・・の様に $2^x$ で表される分数に変換出来ます。
<br>
この場合は以下の様に分数を使って計算すると楽になります。
</p>

<div class="info">
<input type="checkbox"> <b>分数を使って計算するバージョン</b>

<p>
A = 0.625 = 5/8 なので
</p>

<ol>
<li> 有効桁数 を n = 4 ビットとする 
<li> A に 2 をかけると 10/8 = 5/4 = 1+1/4 。積の整数部分は $r_{-1} = 1$、積から $r_{-1}$ を引いた残りは $p_{-1} = 1/4$
<li> $p_{-1} = 1/4 $ に 2 をかけると 1/2 。積の整数部分は $r_{-2} = 0$、積から $r_{-2}$ を引いた残りは $p_{-2} = 1/2$
<li> $p_{-2} = 1/2 $ に 2 をかけると 1 。積の整数部分は $r_{-3} = 1$、積から $r_{-3}$ を引いた残りは $p_{-3} = 0$
<li> $p_{-3} = 0 $ に 2 をかけると 0 。積の整数部分は $r_{-4} = 0$、積から $r_{-4}$ を引いた残りは $p_{-4} = 0$
<li> $p_{-4} = 0 $ に 2 をかけると 0 。積の整数部分は $r_{-5} = 0$、積から $r_{-5}$ を引いた残りは $p_{-5} = 0$
<li> n = 4 + 1 = 5 回繰り返したので計算終了
<li> 以下同じ
</ol>

</div>

<p>
では逆に 0b1010 を小数に変換してみます。
</p>

<div class="info">
<input type="checkbox"> <b>例: 0b1010 を 0 以上かつ1より小さい小数に変換</b>

<p>
A = $1\cdot 2^{-1} + 0\cdot 2^{-2} + 1\cdot 2^{-3} + 0\cdot 2^{-4}$
</p>
<p>
 　=1・(1/2) + 0・(1/4) + 1・(1/8) + 0・(1/16)
</p>
<p>
 　=1/2 + 0 + 1/8 + 0 = 5/8 = 0.625
</p>


</div>

<p>
ところで、A の値によっては有効桁数 n をいくら大きくしても最後の残り $p_{-(n+1)}$ が 0 にならない場合があります(というよりも、ほとんどの場合はそうなります)。
</p>
<p>
例えば A = 0.123、n = 4 の場合を考えてみましょう。
</p>

<div class="info">
<input type="checkbox"> <b>例: 0.123 を 2 進数に変換 (n = 4 )</b>

<p>
A = 0.123 とする
</p>

<ol>
<li> 有効桁数を n = 4 ビットとする
<li> A に 2 をかけると 0.246 。積の整数部分は $r_{-1} = 0$、積から $r_{-1}$ を引いた残りは $p_{-1} = 0.246$
<li> $p_{-1} = 0.246 $ に 2 をかけると 0.492 。積の整数部分は $r_{-2} = 0$、積から $r_{-2}$ を引いた残りは $p_{-2} = 0.492$
<li> $p_{-2} = 0.492 $ に 2 をかけると 0.984 。積の整数部分は $r_{-3} = 0$、積から $r_{-3}$ を引いた残りは $p_{-3} = 0.984$
<li> $p_{-3} = 0.984 $ に 2 をかけると 1.968 。積の整数部分は $r_{-4} = 1$、積から $r_{-4}$ を引いた残りは $p_{-4} = 0.968$
<li> $p_{-4} = 0.968 $ に 2 をかけると 1.936 。積の整数部分は $r_{-5} = 1$、積から $r_{-4}$ を引いた残りは $p_{-5} = 0.936$
<li> n = 4+1 = 5 回繰り返したので計算終了 ※ 最後の残り $p_{-5}$ が 0 で無いことに注目！
<li> $r_{-1}$ を先頭に $r_{-5}$ まで順に並べると 00011
<li> 0b を先頭に付けると0b00011
<li> 最後のビット($r_{-5}$) が 1 なので最後のビットを切り上げる( 0b0001 + 0b1 = 0b0010 )
<li> n = 4 ビットの2進数 0b0010 が得られる
</ol>

</div>

<p>
今回は計算が途中で打ち切られてしまいました。
<br>
では 0b0010 を小数に変換してみましょう。
</p>

<div class="info">
<input type="checkbox"> <b>例: 0b0010 を0 以上かつ 1 より小さい小数に変換</b>

<p>
A = $0\cdot 2^{-1} + 0\cdot 2^{-2} + 1\cdot 2^{-3} + 0\cdot 2^{-4}$
</p>
<p>
 　=0・(1/2) + 0・(1/4) + 1・(1/8) + 0・(1/16)
</p>
<p>
　= 0 + 0 + 1/8 + 0 = 1/8 = 0.125
</p>

</div>

<p>
すると元の値(0.123)とは違う値(0.125)になってしまいました。
</p>

<p>
このように、小数を 2 進数化すると大抵の場合誤差が生じます。
<br>
この誤差のことを「<b>丸め誤差</b>」と呼び、以下の式により計算します。
</p>


<div class="info">
<input type="checkbox"> <b>丸め誤差の定義</b>

<p>
<b>丸め誤差 = 変換後の値 - 元の値</b>
</p>

<p>
※ | 変換後の値 - 元の値 | という様に絶対値を取る定義もあります
</p>

</div>

<p>
上の例の場合、丸め誤差 = 0.125 - 0.123 = 0.002 となります。
</p>

<br>
<script>PreNext(3,3)</script>
</body>
</html>
