<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="stylesheet" href="../../../common.css">
<script src="../../../common.js"></script>
<script src="../../../mathjax.js"></script>
<title>2. (線形)量子化ビット数</title>
</head>
<body>

<nav class="brcr">
<ol>
<li><a href="../">アクティビティ: ディジタル信号処理の基礎</a></li>
<li>学習項目: [3] 量子化</li>
<li><script>GetTitle()</script></li>
</ol>
</nav>

<h2><script>GetTitle()</script></h2>

<p>
「量子化ビット数」 $q$ [bit] とは線形量子化した後のディジタルデータひとつ分を何 bit で記録するかを表す数字で、具体的には $f[i]$ の値域を均等に $2^q-1$ 分割することを意味します。
</p>

<p>
線形量子化ビット数 $q$ [bit] と対応する値域の分割数及び C言語等における整数型の関係を示した表を以下に示します。
</p>

<table>
<tr><th>線形量子化ビット数 $q$ [bit] </th><th>  値域の分割数 </th><th> 整数型変数 </th></tr>
<tr><td class="center"> 1 bit </td><td class="center">  $2^1-1= 1$ 等分              </td><td class="center">  (unsigned) char型<br><br>※ 8 bit 変数なので 1 bitの信号を 8 個格納できます</td></tr>
<tr><td class="center"> 2 bit </td><td class="center">  $2^2-1= 3$ 等分              </td><td class="center">  (unsigned) char型<br><br>※ 8 bit 変数なので 2 bitの信号を 4 個格納できます</td></tr>
<tr><td class="center"> 4 bit </td><td class="center">  $2^4-1= 15$ 等分              </td><td class="center">  (unsigned) char型<br><br>※ 8 bit 変数なので 4 bitの信号を 2 個格納できます</td></tr>
<tr><td class="center"> 8 bit </td><td class="center">  $2^8-1= 255$ 等分            </td><td class="center">  (unsigned) char 型 </td></tr>
<tr><td class="center">16 bit </td><td class="center">  $2^{16}-1= 65535$ 等分       </td><td class="center">  (unsigned) short 型 </td></tr>
<tr><td class="center">24 bit </td><td class="center">  $2^{24}-1= 16777215$ 等分    </td><td class="center">  (unsigned) char型 x 3 個<br><br>※ 24 bit の信号なので格納するためには 8 bit 変数が 3 個必要です </td></tr>
<tr><td class="center">32 bit </td><td class="center">  $2^{32} -1= 4294967295$ 等分 </td><td class="center">  (unsigned) int 型 </td></tr>
</table>

<p>
例えば<a href="./page01.html">前ページ</a>の図 1 の信号を $q$ = 2 bit で量子化した例を以下に示します。
</p>

<div class="info">
<input type="checkbox"><b>図 1 : 前ページの図 1 を $q$ = 2 bit で量子化した例 </b>

<p>
$f[i]$ の値域は [0, 1]で、それが $2^2-1 = 3$ 等分されるので、信号値は 0 か 1/3 か 2/3 か 1 のどれかの値に量子化される。
</p>

<p>
ここで信号値 0 のデータを二進数 0b00 (10進数の0)、1/3 のデータを 0b01 (10進数の1)、2/3 のデータを 0b10(10進数の2)、1 のデータを 0b11 (10進数の3) で記録する事にすると、量子化後の信号は二進数 0b 00 11 00 01 11 10 で表される。
</p>

<img src="./img/page02-fig1.png" alt="">

</div>

<p>
また $q$ = 4 bit で量子化すると次の様になります。
</p>

<div class="info">
<input type="checkbox"><b>図 2: 前ページの図1を $q$ = 4 bit で量子化した例 </b>

<p>
$f[i]$ の値域は [0, 1]で、それが $2^4-1 = 15$ 等分されるので、信号値は 0、1/15、・・・、14/15、1 のどれかの値に量子化される。
</p>

<p>
ここで信号値 0 のデータを二進数 0b0000(10進数の0)、1/15 のデータを 0b0001(10進数の1)、・・・、14/15 のデータを 0b1110(10進数の14)、1 のデータを 0b1111 (10進数の15) で記録する事にすると、量子化後の信号は二進数 0b 0000 1100 0010 0110 1101 1001 で表される。
</p>

<img src="./img/page02-fig2.png" alt="">

</div>

<p>
上の例から分かる様に、量子化ビット数を増やすと量子化誤差は減りますがデータサイズが大きくなります。
</p>

<br>
<script>PreNext(2,2)</script>
</body>
</html>
