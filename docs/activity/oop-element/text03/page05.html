<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="stylesheet" href="../../../common.css">
<script src="../../../common.js"></script>
<title>5. インヘリタンスによるポリモーフィズム</title>
</head>
<body>

<nav class="brcr">
<ol>
<li><a href="../">アクティビティ: オブジェクト指向プログラミングの三大要素</a></li>
<li>学習項目: [3] ポリモーフィズム</li>
<li><script>GetTitle()</script></li>
</ol>
</nav>

<h2><script>GetTitle()</script></h2>

<p>
オブジェクト指向言語では<b>「サブクラスのインスタンスをスーパークラスのインスタンスと見なして作る」</b>ことが出来ます。
<br>
この機能はポリモーフィズムの典型例として良く取り上げられています。
</p>
<p>
とだけ言っても良く分からないと思うので、これから具体的なコードを使って順を追って説明していきます。
</p>
<p>
まず大元の FRUIT スーパークラスをソース 1 で定義します。
</p>
<div class="info">
<input type="checkbox"><b>ソース 1 : FRUIT スーパークラス</b>
<pre class="wrap">
public class FRUIT {

    public String name;

    public void eat(){
        System.out.println(name+"美味い");
    }
}
</pre>
</div>
<p>
この FRUIT スーパークラスを継承させて APPLE サブクラス(ソース 2 )と ORANGE サブクラス(ソース 3 )を作ります。
</p>
<div class="info">
<input type="checkbox"><b>ソース 2 : APPLE サブクラス</b>
<pre class="wrap">
public class APPLE extends FRUIT{

    public APPLE(){
        name = "りんご";
    }
}
</pre>
</div>

<br>
<div class="info">
<input type="checkbox"><b>ソース 3 : ORANGE サブクラス</b>
<pre class="wrap">
public class ORANGE extends FRUIT{

    public ORANGE(){
        name = "みかん";
    }
}
</pre>
</div>

<p>
次に main メソッドをソース 4 に示しますが、今まで習ってきた方法と違って
</p>
<p>
<b>apple と orange が FRUIT スーパークラスのインスタンスになっている</b>
</p>
<p>
ことに注目して下さい。
</p>

<div class="info">
<input type="checkbox"><b>ソース 4 : Main クラスと main メソッド</b>
<pre class="wrap">
public class Main{

	public static void main(String[] args) {

		FRUIT apple = new APPLE();   // ※ 今までは「APPLE apple = new APPLE();」 と new していた！
		FRUIT orange = new ORANGE(); // ※ 今までは「ORANGE orange = new ORANGE();」 と new していた！

		apple.eat();
		orange.eat();
	}
}
</pre>
</div>

<p>
インスタンス apple と orange の実態はそれぞれ APPLE、ORANGE サブクラスのインスタンスなのですが、見かけ上は FRUIT スーパークラスのインスタンスになりますので
</p>
<p>
<b>同じ FRUIT クラスの同じ eat() メソッドを呼び出しているのにインスタンス apple と orange で結果が異なる</b>
</p>
<p>
結果になります(実行結果 1 )。
</p>

<div class="info">
<input type="checkbox"><b>実行結果 1 :</b>
<pre class="wrap">
りんご美味しい
みかん美味しい
</pre>
</div>

<p>
なお、インヘリタンスによるポリモーフィズムを応用すると、次のソース 5 の様にクラス別にメソッドを分けなくてもスーパークラスの引数としてメソッド呼び出しをしたり、ソース 6 の様にスーパークラスの<a href="../../java-basic/text04/page01.html">リスト</a>と<a href="../../java-basic/text05/page03.html">forEach</a> を使って異なるサブクラスの複数のインスタンスを一元管理したり出来るようになります。
</p>
<p>
これらのテクニックは非常に良く使われますので覚えておくと良いでしょう。
</p>

<div class="info">
<input type="checkbox"><b>ソース 5 : メソッドの引数をスーパークラスにする例</b>
<pre class="wrap">
public class Main{

	public static void Hoge( FRUIT f )
	{
	        f.eat();  // ※ f の実態が APPLE なのか ORANGE なのかプログラマは気にする必要が無い！
	}

	public static void main(String[] args) {

		APPLE apple = new APPLE();    // ※ apple は APPLE のインスタンス！
		ORANGE orange = new ORANGE(); // ※ orange は ORANGE のインスタンス！

		Hoge( apple );
		Hoge( orange );
	}
}

結果:

りんご美味しい
みかん美味しい
</pre>
</div>

<br>
<div class="info">
<input type="checkbox"><b>ソース 6 : スーパークラスのリストにサブクラスのインスタンスを追加する例</b>
<pre class="wrap">
import java.util.ArrayList;

public class Main{

	public static void main(String[] args) {

	        ArrayList&lt;FRUIT&gt; list = new ArrayList&lt;FRUIT&gt;();

	        list.add(new APPLE()); // ※ FRUIT のリストに APPLE のインスタンスを追加！
	        list.add(new ORANGE());// ※ FRUIT のリストに ORANGE のインスタンスを追加！
        
	        list.forEach( i -> i.eat() );
	}
}


結果:

りんご美味しい
みかん美味しい
</pre>
</div>

<br>
<script>PreNext(5,6)</script>
</body>
</html>
